{
    "folderStructure": {
      "description": "Recommended folder structure within the Next.js `app/` directory for a scalable backend.",
      "structure": [
        "app/",
        "├── api/",
        "│   ├── auth/",
        "│   │   ├── login/",
        "│   │   │   └── route.ts",
        "│   │   └── signup/",
        "│   │       └── route.ts",
        "│   ├── chat/",
        "│   │   ├── history/",
        "│   │   │   └── route.ts",
        "│   │   └── route.ts",
        "├── lib/",
        "│   ├── prisma.ts       # Prisma client singleton",
        "│   └── auth.ts         # JWT handling utilities",
        "├── services/",
        "│   └── aiService.ts    # Logic for interacting with OpenRouter/Requesty.ai",
        "├── utils/",
        "│   └── validation.ts   # Input validation schemas/functions (e.g., using Zod)",
        "├── middleware.ts       # Optional: For protecting routes",
        "prisma/",
        "├── schema.prisma",
        "├── migrations/",
        ".env                    # Environment variables (DB_URL, JWT_SECRET, AI_API_KEY)",
        "package.json",
        "tsconfig.json",
        "next.config.mjs"
      ]
    },
    "prismaSchema": {
      "description": "Prisma schema definition (`prisma/schema.prisma`) for User, Chat, and Message models.",
      "code": "// This is your Prisma schema file,\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\" // Or your preferred database (mysql, sqlite, etc.)\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id        String   @id @default(cuid())\n  email     String   @unique\n  password  String\n  chats     Chat[]\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n\nmodel Chat {\n  id        String    @id @default(cuid())\n  userId    String\n  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)\n  messages  Message[]\n  title     String?   // Optional: Title for the chat session\n  createdAt DateTime  @default(now())\n  updatedAt DateTime  @updatedAt\n\n  @@index([userId])\n}\n\nenum MessageRole {\n  USER\n  ASSISTANT\n}\n\nmodel Message {\n  id        String      @id @default(cuid())\n  chatId    String\n  chat      Chat        @relation(fields: [chatId], references: [id], onDelete: Cascade)\n  role      MessageRole // 'USER' or 'ASSISTANT'\n  content   String      @db.Text // Use Text for potentially long messages\n  createdAt DateTime    @default(now())\n\n  @@index([chatId])\n}"
    },
    "authRoutes": {
      "description": "API routes for user signup and login using Next.js App Router Route Handlers, bcryptjs for hashing, and jsonwebtoken for JWT.",
      "signup": {
        "path": "app/api/auth/signup/route.ts",
        "code": "import { NextResponse } from 'next/server';\nimport { PrismaClient } from '@prisma/client';\nimport bcrypt from 'bcryptjs';\nimport { z } from 'zod';\n\nconst prisma = new PrismaClient();\n\n// Input validation schema\nconst signupSchema = z.object({\n  email: z.string().email({ message: 'Invalid email address' }),\n  password: z.string().min(8, { message: 'Password must be at least 8 characters long' }),\n});\n\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n\n    // Validate input\n    const validationResult = signupSchema.safeParse(body);\n    if (!validationResult.success) {\n      return NextResponse.json({ error: 'Invalid input', details: validationResult.error.errors }, { status: 400 });\n    }\n\n    const { email, password } = validationResult.data;\n\n    // Check if user already exists\n    const existingUser = await prisma.user.findUnique({\n      where: { email },\n    });\n\n    if (existingUser) {\n      return NextResponse.json({ error: 'User already exists with this email' }, { status: 409 }); // 409 Conflict\n    }\n\n    // Hash password\n    const hashedPassword = await bcrypt.hash(password, 10); // Salt rounds = 10\n\n    // Create user\n    const newUser = await prisma.user.create({\n      data: {\n        email,\n        password: hashedPassword,\n      },\n    });\n\n    // Omit password from the response\n    const { password: _, ...userWithoutPassword } = newUser;\n\n    return NextResponse.json({ message: 'User created successfully', user: userWithoutPassword }, { status: 201 });\n\n  } catch (error) {\n    console.error('Signup Error:', error);\n    // Generic error for security\n    return NextResponse.json({ error: 'An internal server error occurred' }, { status: 500 });\n  } finally {\n    await prisma.$disconnect();\n  }\n}"
      },
      "login": {
        "path": "app/api/auth/login/route.ts",
        "code": "import { NextResponse } from 'next/server';\nimport { PrismaClient } from '@prisma/client';\nimport bcrypt from 'bcryptjs';\nimport jwt from 'jsonwebtoken';\nimport { z } from 'zod';\n\nconst prisma = new PrismaClient();\n\n// Input validation schema\nconst loginSchema = z.object({\n  email: z.string().email({ message: 'Invalid email address' }),\n  password: z.string().min(1, { message: 'Password cannot be empty' }), // Basic check\n});\n\nconst JWT_SECRET = process.env.JWT_SECRET;\n\nif (!JWT_SECRET) {\n  throw new Error('JWT_SECRET environment variable is not defined');\n}\n\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n\n    // Validate input\n    const validationResult = loginSchema.safeParse(body);\n    if (!validationResult.success) {\n      return NextResponse.json({ error: 'Invalid input', details: validationResult.error.errors }, { status: 400 });\n    }\n\n    const { email, password } = validationResult.data;\n\n    // Find user by email\n    const user = await prisma.user.findUnique({\n      where: { email },\n    });\n\n    if (!user) {\n      return NextResponse.json({ error: 'Invalid email or password' }, { status: 401 }); // Unauthorized\n    }\n\n    // Compare passwords\n    const isPasswordValid = await bcrypt.compare(password, user.password);\n\n    if (!isPasswordValid) {\n      return NextResponse.json({ error: 'Invalid email or password' }, { status: 401 }); // Unauthorized\n    }\n\n    // Generate JWT\n    const token = jwt.sign(\n      { userId: user.id, email: user.email }, // Payload\n      JWT_SECRET,\n      { expiresIn: '1h' } // Token expiration time (e.g., 1 hour)\n    );\n\n    return NextResponse.json({ message: 'Login successful', token }, { status: 200 });\n\n  } catch (error) {\n    console.error('Login Error:', error);\n    return NextResponse.json({ error: 'An internal server error occurred' }, { status: 500 });\n  } finally {\n    await prisma.$disconnect();\n  }\n}"
      },
      "authUtils": {
        "path": "app/lib/auth.ts",
        "code": "import jwt, { JwtPayload } from 'jsonwebtoken';\nimport { NextRequest } from 'next/server';\n\nconst JWT_SECRET = process.env.JWT_SECRET;\n\ninterface AuthPayload extends JwtPayload {\n  userId: string;\n  email: string;\n}\n\nexport function verifyAuth(req: NextRequest): AuthPayload | null {\n  if (!JWT_SECRET) {\n    console.error('JWT_SECRET is not defined');\n    return null;\n  }\n\n  const authHeader = req.headers.get('Authorization');\n  const token = authHeader?.split(' ')[1]; // Bearer <token>\n\n  if (!token) {\n    return null;\n  }\n\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET) as AuthPayload;\n    return decoded;\n  } catch (error) {\n    console.error('JWT Verification Error:', error);\n    return null;\n  }\n}\n\n// Optional: Middleware example (middleware.ts)\n/*\nimport { NextRequest, NextResponse } from 'next/server';\nimport { verifyAuth } from './lib/auth';\n\nexport const config = {\n  matcher: ['/api/chat/:path*'], // Protect chat-related API routes\n};\n\nexport function middleware(req: NextRequest) {\n  const decodedToken = verifyAuth(req);\n\n  if (!decodedToken) {\n    return NextResponse.json({ error: 'Unauthorized: Invalid or missing token' }, { status: 401 });\n  }\n\n  // Add user info to request headers if needed downstream (optional)\n  // const requestHeaders = new Headers(req.headers);\n  // requestHeaders.set('X-User-Id', decodedToken.userId);\n  // requestHeaders.set('X-User-Email', decodedToken.email);\n  // return NextResponse.next({ request: { headers: requestHeaders } });\n\n  return NextResponse.next();\n}\n*/"
      },
      "prismaClient": {
        "path": "app/lib/prisma.ts",
        "code": "import { PrismaClient } from '@prisma/client';\n\ndeclare global {\n  // allow global `var` declarations\n  // eslint-disable-next-line no-var\n  var prisma: PrismaClient | undefined;\n}\n\nexport const prisma = global.prisma || new PrismaClient({\n  // log: ['query'], // Uncomment to log Prisma queries\n});\n\nif (process.env.NODE_ENV !== 'production') global.prisma = prisma;"
      }
    },
    "chatRoute": {
      "description": "API route (`/api/chat`) for handling user messages, interacting with the AI service, saving messages, and returning the AI response. Assumes JWT verification is handled (e.g., by middleware or directly within the route).",
      "path": "app/api/chat/route.ts",
      "code": "import { NextResponse, NextRequest } from 'next/server';\nimport { z } from 'zod';\nimport { prisma } from '@/lib/prisma'; // Use singleton instance\nimport { verifyAuth } from '@/lib/auth'; // JWT verification helper\nimport { getAIResponse } from '@/services/aiService'; // Placeholder for AI interaction logic\nimport { MessageRole } from '@prisma/client';\n\n// Input validation schema\nconst chatRequestSchema = z.object({\n  message: z.string().min(1, { message: 'Message cannot be empty' }),\n  chatId: z.string().cuid().optional(), // Optional: for continuing existing chats\n});\n\nexport async function POST(request: NextRequest) {\n  // 1. Verify Authentication\n  const authPayload = verifyAuth(request);\n  if (!authPayload) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n  }\n  const userId = authPayload.userId;\n\n  try {\n    const body = await request.json();\n\n    // 2. Validate Input\n    const validationResult = chatRequestSchema.safeParse(body);\n    if (!validationResult.success) {\n      return NextResponse.json({ error: 'Invalid input', details: validationResult.error.errors }, { status: 400 });\n    }\n\n    const { message: userMessageContent, chatId: existingChatId } = validationResult.data;\n\n    let chatId = existingChatId;\n    let chatHistory: { role: MessageRole; content: string }[] = [];\n\n    // 3. Handle Chat Session (Create new or use existing)\n    if (!chatId) {\n      // Create a new chat session\n      const newChat = await prisma.chat.create({\n        data: {\n          userId: userId,\n          // Optionally set a title later, e.g., based on the first message\n          // title: userMessageContent.substring(0, 50) + '...'\n        },\n      });\n      chatId = newChat.id;\n    } else {\n      // Verify the user owns the chat and fetch history\n      const chat = await prisma.chat.findUnique({\n        where: { id: chatId, userId: userId }, // Ensure user owns the chat\n        include: {\n          messages: {\n            orderBy: { createdAt: 'asc' }, // Get history in chronological order\n            select: { role: true, content: true },\n            take: 10, // Limit history context sent to AI (adjust as needed)\n          },\n        },\n      });\n\n      if (!chat) {\n        return NextResponse.json({ error: 'Chat not found or access denied' }, { status: 404 });\n      }\n      chatHistory = chat.messages;\n    }\n\n    // 4. Save User Message\n    await prisma.message.create({\n      data: {\n        chatId: chatId,\n        role: MessageRole.USER,\n        content: userMessageContent,\n      },\n    });\n\n    // 5. Prepare context and call AI Service\n    const messagesForAI = [\n      ...chatHistory, // Include previous messages for context\n      { role: MessageRole.USER, content: userMessageContent },\n    ];\n\n    // --- Replace with actual AI Service call --- \n    const aiResponseContent = await getAIResponse(messagesForAI);\n    // --- End of AI Service call --- \n\n    if (!aiResponseContent) {\n        return NextResponse.json({ error: 'Failed to get AI response' }, { status: 500 });\n    }\n\n    // 6. Save AI Response\n    const aiMessage = await prisma.message.create({\n      data: {\n        chatId: chatId,\n        role: MessageRole.ASSISTANT,\n        content: aiResponseContent,\n      },\n    });\n\n    // 7. Return AI Response (and potentially the chatId for new chats)\n    return NextResponse.json(\n      { \n        response: aiMessage.content, \n        chatId: chatId, \n        messageId: aiMessage.id \n      }, \n      { status: 200 }\n    );\n\n  } catch (error) {\n    console.error('Chat API Error:', error);\n    if (error instanceof z.ZodError) {\n        return NextResponse.json({ error: 'Invalid input', details: error.errors }, { status: 400 });\n    }\n    // Handle potential errors from AI service or database\n    return NextResponse.json({ error: 'An internal server error occurred during chat processing' }, { status: 500 });\n  }\n  // Prisma client disconnect is handled globally or less frequently in long-running serverless functions\n}"
    },
    "historyRoute": {
      "description": "API route (`/api/chat/history`) for retrieving messages for a specific chat session. Requires chatId as a query parameter.",
      "path": "app/api/chat/history/route.ts",
      "code": "import { NextResponse, NextRequest } from 'next/server';\nimport { prisma } from '@/lib/prisma';\nimport { verifyAuth } from '@/lib/auth';\nimport { z } from 'zod';\n\n// Define schema for query parameters\nconst historyQuerySchema = z.object({\n  chatId: z.string().cuid({ message: 'Valid chatId query parameter is required' }),\n});\n\nexport async function GET(request: NextRequest) {\n  // 1. Verify Authentication\n  const authPayload = verifyAuth(request);\n  if (!authPayload) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n  }\n  const userId = authPayload.userId;\n\n  // 2. Get and Validate Query Parameter (chatId)\n  const { searchParams } = new URL(request.url);\n  const queryParams = Object.fromEntries(searchParams.entries());\n\n  const validationResult = historyQuerySchema.safeParse(queryParams);\n  if (!validationResult.success) {\n    return NextResponse.json({ error: 'Invalid query parameters', details: validationResult.error.errors }, { status: 400 });\n  }\n  const { chatId } = validationResult.data;\n\n  try {\n    // 3. Fetch Chat and Messages, ensuring user owns the chat\n    const chat = await prisma.chat.findUnique({\n      where: {\n        id: chatId,\n        userId: userId, // Crucial security check: user must own the chat\n      },\n      include: {\n        messages: {\n          orderBy: { createdAt: 'asc' }, // Order messages chronologically\n          select: {\n            id: true,\n            role: true,\n            content: true,\n            createdAt: true,\n          },\n        },\n      },\n    });\n\n    if (!chat) {\n      // If chat doesn't exist or doesn't belong to the user\n      return NextResponse.json({ error: 'Chat not found or access denied' }, { status: 404 });\n    }\n\n    // 4. Return Messages\n    return NextResponse.json({ history: chat.messages }, { status: 200 });\n\n  } catch (error) {\n    console.error('Chat History Error:', error);\n     if (error instanceof z.ZodError) {\n        return NextResponse.json({ error: 'Invalid input', details: error.errors }, { status: 400 });\n    }\n    return NextResponse.json({ error: 'An internal server error occurred while fetching chat history' }, { status: 500 });\n  }\n}"
    },
    "aiServicePlaceholder": {
        "description": "Placeholder service function for interacting with the external AI API (e.g., OpenRouter, Requesty.ai). Replace with actual SDK or fetch implementation.",
        "path": "app/services/aiService.ts",
        "code": "import { MessageRole } from '@prisma/client';\n\n// Define the expected message format for the AI service\ninterface AIMessage {\n  role: 'user' | 'assistant' | 'system'; // Adjust roles based on the specific AI API\n  content: string;\n}\n\n// Placeholder function for fetching AI response\nexport async function getAIResponse(messages: { role: MessageRole; content: string }[]): Promise<string | null> {\n  const API_KEY = process.env.AI_API_KEY;\n  const API_ENDPOINT = process.env.AI_API_ENDPOINT; // e.g., 'https://openrouter.ai/api/v1/chat/completions'\n\n  if (!API_KEY || !API_ENDPOINT) {\n    console.error('AI Service API Key or Endpoint is not configured in environment variables.');\n    return 'Error: AI service is not configured.'; // Return an error message or handle appropriately\n  }\n\n  // Map Prisma roles to AI service roles (example)\n  const formattedMessages: AIMessage[] = messages.map(msg => ({\n    role: msg.role === MessageRole.USER ? 'user' : 'assistant',\n    content: msg.content,\n  }));\n\n  // Add a system prompt if needed (optional)\n  // formattedMessages.unshift({ role: 'system', content: 'You are a helpful assistant.' });\n\n  try {\n    const response = await fetch(API_ENDPOINT, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${API_KEY}`,\n        // Add any other required headers for specific providers (e.g., OpenRouter routing headers)\n        // 'HTTP-Referer': 'YOUR_SITE_URL', // Optional: Recommended by OpenRouter\n        // 'X-Title': 'YOUR_APP_NAME',    // Optional: Recommended by OpenRouter\n      },\n      body: JSON.stringify({\n        model: process.env.AI_MODEL_NAME || 'openai/gpt-3.5-turbo', // Specify the model (get from env)\n        messages: formattedMessages,\n        // Add other parameters like temperature, max_tokens etc. as needed\n        // stream: false, // Set to true for streaming responses (requires different handling)\n      }),\n    });\n\n    if (!response.ok) {\n      const errorBody = await response.text();\n      console.error(`AI API Error (${response.status}): ${errorBody}`);\n      return `Error: Failed to get response from AI service (Status: ${response.status}).`;\n    }\n\n    const data = await response.json();\n\n    // Extract the response content - Structure depends on the AI provider\n    // Example for OpenAI/OpenRouter compatible API:\n    const aiContent = data.choices?.[0]?.message?.content;\n\n    if (!aiContent) {\n        console.error('AI API Error: No content found in response', data);\n        return 'Error: Received an empty response from AI.'\n    }\n\n    return aiContent.trim();\n\n  } catch (error) {\n    console.error('Error calling AI service:', error);\n    return 'Error: Could not connect to the AI service.';\n  }\n}"
    },
    "bestPractices": {
      "description": "Summary of best practices for building this Next.js backend API.",
      "points": [
        "**Input Validation:** Use libraries like Zod (`zod`) to strictly validate all incoming request bodies, query parameters, and path parameters. Return detailed 400 Bad Request errors on validation failure.",
        "**Error Handling:** Implement consistent error handling using try-catch blocks in API routes. Log errors server-side for debugging (but don't expose sensitive details to the client). Return appropriate HTTP status codes (e.g., 400, 401, 403, 404, 409, 500) and clear, concise error messages in the JSON response.",
        "**Security - Authentication:**",
        "  - Hash passwords using a strong algorithm like bcrypt (`bcryptjs`) with sufficient salt rounds.",
        "  - Use JSON Web Tokens (JWT) for session management. Sign JWTs with a strong, secret key stored securely in environment variables (`process.env.JWT_SECRET`).",
        "  - Set reasonable expiration times for JWTs (`expiresIn`).",
        "  - Implement JWT verification (e.g., in middleware or at the start of protected routes) to secure endpoints.",
        "  - Consider refresh tokens for longer-lived sessions if needed (beyond MVP).",
        "**Security - General:**",
        "  - Store all sensitive information (database URLs, API keys, JWT secrets) in environment variables (`.env` file, added to `.gitignore`).",
        "  - Protect against Cross-Site Scripting (XSS) by properly handling/sanitizing any user-generated content if it were ever rendered directly in HTML (less critical for pure API, but good practice).",
        "  - Protect against Cross-Site Request Forgery (CSRF) if using cookie-based sessions (JWT in Auth header is generally less susceptible).",
        "  - Implement Rate Limiting on sensitive endpoints (like login, signup, and potentially chat) to prevent abuse (consider libraries like `rate-limiter-flexible`).",
        "  - Ensure database queries properly authorize access (e.g., when fetching chat history, always filter by `userId` to prevent users from seeing others' data).",
        "**Prisma:**",
        "  - Use the Prisma Client singleton pattern (`lib/prisma.ts`) to avoid creating too many database connections, especially in serverless environments.",
        "  - Define clear relations and use cascading deletes (`onDelete: Cascade`) where appropriate (e.g., deleting a user deletes their chats).",
        "  - Use Prisma transaction API (`prisma.$transaction([...])`) for operations that must succeed or fail together (e.g., creating user and AI messages within the chat endpoint).",
        "**Code Structure & Maintainability:**",
        "  - Organize code logically into folders (e.g., `api`, `lib`, `services`, `utils`).",
        "  - Use TypeScript for static typing to catch errors early and improve code clarity.",
        "  - Keep API route handlers focused; extract complex logic into separate service functions (like `aiService.ts`).",
        "  - Use descriptive variable and function names.",
        "  - Add comments where logic is complex or non-obvious.",
        "**API Design:**",
        "  - Follow RESTful principles where applicable.",
        "  - Use appropriate HTTP methods (POST for creation/actions, GET for retrieval, PUT/PATCH for updates, DELETE for removal).",
        "  - Return consistent JSON response structures for success and error cases.",
        "**Dependencies:** Keep dependencies updated to patch security vulnerabilities."
      ]
    }
  }